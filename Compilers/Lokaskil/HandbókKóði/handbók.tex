%%
%%  Beinagrind fyrir Morpho handbók í LaTeX.
%%  Til að keyra þetta gegnum LaTeX forritið
%%  má t.d. nota pdflatex í cygwin með eftir-
%%  farandi skipun í bash:
%%
%%       pdflatex handbok
%%   eða (virkar líka í cmd):
%%       bash -c 'pdflatex handbok'
%%
\documentclass[12pt,a4paper]{article}
\usepackage[icelandic]{babel}
\usepackage[pdftex]{hyperref}
%\usepackage{makeidx,smplindx,fancyhdr,graphicx,times,multicol,comment}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage[rounded]{syntax}
\usepackage{graphicx}
\usepackage{color}
\definecolor{light-gray}{gray}{0.85}
\usepackage{listings}
\lstset{
    numbers=left,
    breaklines=true,
    backgroundcolor=\color{light-gray},
    tabsize=2,
    basicstyle=\ttfamily,
}
\usepackage[a4paper, total={7in, 10in}]{geometry}
\newenvironment{repnull}[0]{%
	\begin{stack}
	\\
	\begin{rep}
}{%
	\end{rep}
	\end{stack}
}
\newenvironment{málrit}[1]{%
	\par\noindent\begin{minipage}{\linewidth}\vspace{0.5em}\begin{quote}\noindent%
	\hspace*{-2em}\synt{#1}:\hfill\par%
	\noindent%
	\begin{minipage}{\linewidth}\begin{syntdiag}%
}{%
	\end{syntdiag}\end{minipage}\end{quote}\end{minipage}%
}

\begin{document}
\sloppy
\title{Handbók fyrir NanoMorpho}
\author{Pétur Daníel Ámundason}
\maketitle

\pagebreak

\tableofcontents

\pagebreak

\section{Inngangur}

\paragraph{Enn einn þýðandi NanoMorpho} Einföld útgáfa af Morpho. NanoMorpho er bálkmótað mál.

\section{Notkun og uppsetning}

\paragraph{Uppsetning} Notast skal við Git til þess að sækja þýðandan.

\paragraph{Git} \$ Git clone https://Github.com/rutep/NanoMorpho.Git
\\
Þegar náð hefur verið í skrár þá eru þær þrjár skrár. \textbf{NanoMorphoLexer.java} sem er lesgreinir, \textbf{NanoMorphoParser.java} og \textbf{NanoMorphoParserVal.java} sem sjá um þáttun og milli þulusmíði.

\paragraph{Morpho} Morphoskrárnar eru til þess að geta þýtt  \textbf{NanoMorpho} skrár  yfir á Morpho smalarmál og smalarmálið yfir í keyrslu hæfa Morphoskrá. Þegar fyrrnefnda er búið þá er hægt að keyra forritið í gegnum Morpho.

\paragraph{makefile} Hér fyrir neðan sést makefile skrá sem hægt er að nota til þess að auðvelda sér þýðingu og keyrslu \textbf{NanoMorpho} forrits. Ef búnaður er ekki til staðar til þess að nota makefile skrá þá er hægt að keyra beint skipanir á skipunarlínu ef java þýðandi og Morpho er upp sett.

\begin{itemize}
	\item \$ javac NanoMorphoLexer.java NanoMorphoParser.java NanoMorphoParserVal.java 
	\item Skipuninn að ofan þýðir java skrár
	\item \$ java NanoMorphoParser test.s > test.masm
	\item Býr til Morpho smalarmáls skrá test.masm
	\item \$ Morpho -c test.masm
	\item \$ Morpho test
	\item Býr til test.mexem skrá og svo keyrir forrit
\end{itemize}

\begin{lstlisting}
SHELL=/usr/bin/env /bin/bash

parser: NanoMorphoParser.java NanoMorphoParserVal.java NanoMorphoLexer.java
javac NanoMorphoLexer.java NanoMorphoParser.java NanoMorphoParserVal.java

test: NanoMorphoParser.class NanoMorphoParserVal.class
java NanoMorphoParser test.s > test.masm 

compile: test.masm
Morpho -c test.masm

run: test.mexe
Morpho test 
	
\end{lstlisting}

\section{Málfræði}
\subsection{Frumeiningar málsins}

\paragraph{Samhengislaust mál} Línubil og línu endingar hafa enga merkingu fyrir þíðandan og væri hægt að skrifa heilu forritin í einni línu með engum línubilum.
\subsubsection{Athugasemd}
\paragraph{Dæmi um athugasemd} ;;; Hunsað af þýðanda
Þýðandinn mun hunsa allt sem kemur á eftir athugarsemdar í þeirri línu sem hún er.

\subsubsection{Lykilorð}
Lykilorðin í þýðandanum eru:\\
else, elsif, false, if, null, return, true, var, while, println
\subsection{Mállýsing}

\begin{málrit}{idlist}
	\begin{stack}
		\\
		\begin{rep} <NAME> \\ `,' \end{rep}
	\end{stack}
\end{málrit}%

\begin{málrit}{exprs}
	\begin{rep}
		<expr> ';'
	\end{rep}
\end{málrit}%

\subsubsection{Forrit}

\begin{málrit}{program}
	\begin{rep}
		<function>
	\end{rep}
\end{málrit}

\subsubsection{Föll}

\begin{málrit}{function}
	<NAME> `(' <idlist> `)' '\{' <VAR>  <idlist> ';' <exprs> '\}'
\end{málrit}

\subsubsection{Stofnar}
\begin{málrit}{body}
	`{' 
		\begin{rep}
		<expr> ';'	
		\end{rep}
	`}' 
\end{málrit}

\subsubsection{Segðir}

\begin{málrit}{expr}
	\begin{stack}
		<RETURN> <expr>	
		\\
		<NAME> '=' <expr>
		\\
		<NOT> <expr>
		\\
		<expr> <AND> <expr>
		\\
		`while' '(' <expr> ')' <body>
		\\
		'println' '(' <expr> ')'
		\\
		`if' '(' <expr> ')' <body> <ifrest>
		\\
		`if' '(' <expr> ')' <body>
		\\
		<expr> <OP> <expr>
		\\
		'(' <expr> ')'
		\\
		<NAME> '(' arg ')'
		\\
		<OP> <expr>
		\\
		<NAME>
		\\
		<int>
		\\
		<float>
		\\
		<string>
		\\
		<char>
		\\
		`true'
		\\
		`false'
		\\
		`null'
	\end{stack}
\end{málrit}

\begin{málrit}{arg}
	\begin{rep}
		expr \\ ','
	\end{rep}
\end{málrit}

\begin{málrit}{ifrest}
	\begin{stack}
		'else' <body>
		\\
		'elseif' '(' <expr> ')' <body>
		\\
		'elseif' '(' <expr> ')' <body> <ifrest>
	\end{stack}
\end{málrit}
		
\section{Merking málsins}
NanoMorpho skiptis upp í að það er eitt main fall sem keyrt er og úr því er hægt að kalla á önnur skilgreind föll.

\begin{lstlisting}
	foo(){
		var a;
		a = 1;
		return a;	
	}
	
	main(){
		var a;
		a = foo();
	}
\end{lstlisting}


\subsection{Breytur}

Fyrsta gildisveitinginn sem á sér stað er þegar breyta er búinn til , þá mun hún innihalda null gildið. Seinna meir í stofni falls er hægt að gefa henni nýtt gildi. Notkunardæmi er hér fyir neðan. Breytunöfn verða hafa a.m.k. einn bókstaf í sér og geta innihaldið tölur.

\begin{lstlisting}
	main(){
		var a;	;;; a = null
		a = 0;  ;;; a = 0
	}
\end{lstlisting}


\subsection{Merking segða}
\subsubsection{null-segð}
Þjónar þeim tilgangi að sýna fram á að breyta hafi ekki verið gefið neitt gildi.
\subsubsection{true-false segð}
Boolean gildi true notað í boolean reikningi.
\subsubsection{false-segð}
Boolean gidli false notað í boolean reikningi.
\subsubsection{Heiltölusegð}
Heiltölu gildi.
\subsubsection{Fleytitölusegð}
Fleititölu gildi.
\subsubsection{Stafsegð}
Stafsegðar gildi 's'.
\subsubsection{Strengsegð}
Strengsegðar gildi "Strengsegð".
\pagebreak
\subsubsection{return-segð}
Return skilar gildi úr falli. Notkunardæmi:
\begin{lstlisting}
	foo(){
		return 1;	;;; Skilar 1 ef kallað er á
	}	
	
\end{lstlisting}
\subsubsection{Röksegðir}
Röksegðir eru  or ||, and \&\&, !=, >=, <= og == .\\
Þær eru að mestu leiti reiknaðar frá vinstri til hægri. Notkunardæmi:

\begin{lstlisting}
				;;; gefur 
	1 != 2 			;;; true
	true || false 		;;; true
	true && true 		;;; true
	1 >= 1			;;; true
	1 <= 1			;;; true
	1 == 1			;;; true
\end{lstlisting}
\subsubsection{Kallsegð}
Fall eru annað hvort úr basis eða gert af notenda. Fall tekur inn breytur sem viðföng og reikningur úr þeim er frá vinstri til hægri. Dæmi um slíkt fall sem notendi getur gert og notkun:
\begin{lstlisting}
	foo(a,b,s){
		var t;
		return 1;
	}
	
	main(){
		var x;
		x = foo(1+1,2-5,-3);	;;; foo fall skilar einum
	}
\end{lstlisting}

\subsubsection{Tvíundaraðgerðir}
Tvíundaraðgerðir eru á infix formi.
\subsubsection{Einundaraðgerðir}
Einundaraðgerðir hafa hæsta forgang.
\pagebreak
\subsubsection{if-segð}
Hér er dæmi um notkun á if elsif else segðum. Ef s1 er satt þá body1. Ef s1 ósatt og s2 satt þá body2. Ef s1 og s2 ósatt þá body3.
\begin{lstlisting}
	main(){
		var s1,s2,s3;
		if(s1){
			;;; body1		
		} elsif (s2) {
			;;; body2
		} else {
			;;; body3		
		};
	}
\end{lstlisting}
\subsubsection{while-segð}
while-segðin mun alltaf keyrast ef ástandið s1 helst satt. Dæmi um while-segð. Í gefni while-segð ef röksegðini s1 helst sönn þá mun fyrir hvert stef í while lykkju i hækka um einn.

\begin{lstlisting}
	main(){
	var i;
	i = 0;
	while(s1){
		i = i + 1;		
	};
	}
\end{lstlisting}
\subsection{Föll og forrit}
Hér er dæmi um heilt NanoMorpho forrit. Þetta forrit reiknar fyrstu 12 Fibonacci tölurnar.

\begin{lstlisting}
;;; Fibonacci
	fibo(n){
  		var ;
  		if(n < 0) {
    		return n * -1; 
  		} elsif( n == 0) { 
    		return n * ( 1 - 2);
  		} else {
    		return fibo(n-1) + fibo(n-2);
  		};
	}
	main(){
  		var n;
  		n = 0;
  		while(n < 12){
    			n = n+1;
    			println(fibo(n)); }; } 
\end{lstlisting}


\section{Byjaccj skrá}
\begin{lstlisting}
%{
	import java.io.*;
	import java.util.*;
%}


%token<sval> LITERAL,NAME,OPNAME,ERROR,PRINTLN
%token<sval> OP1,OP2,OP3,OP4,OP5
%token IF,ELSE,ELSIF,WHILE,VAR,UNOP
%token RETURN
%type <sval> op

%right RETURN, '='
%right OR
%right AND
%right NOT
%left OP1			
%left OP2			
%left OP3     
%left OP4			
%left OP5			
%right UNOP

%type <obj> program ,fundecl, expr, exprs, args, arglist, body, bodyexpr, ifrest
%type <ival> ids, idlist

%%

start										/*@ \label{grammarstart} @*/
  : program 				{ generateProgram(name,((Vector<Object>)($1)).toArray()); }
	;

program
  : program fundecl { ((Vector<Object>)($1)).add($2); $$=$1; }
  | fundecl         { $$=new Vector<Object>(); ((Vector<Object>)($$)).add($1); }
	;

fundecl
  : {
      varCount = 0;
      varTable = new HashMap<String,Integer>();
    }
    NAME '(' ids ')' '{'
      VAR idlist ';'
			exprs
		'}'
    {
      $$ = new Object[]{$2,$4,$8+$4,((Vector<Object>)($10)).toArray()};
    }
  ;

ids
	:	/* empty */		{ $$=0; }
	| ids ',' NAME  { addVar($3); $$=$1+1; }
  | NAME          { addVar($1); $$+=1; }
  ;


idlist
  :	/* empty */				{ $$=0; }
	| idlist ',' NAME 	{ addVar($3); $$=$1+1; }
  | NAME            	{ addVar($1); $$+=1; }
	;

exprs
	: exprs expr ';' 		{ ((Vector<Object>)($1)).add($2); $$=$1; }
	| expr ';'			 		{ $$=new Vector<Object>(); ((Vector<Object>)($$)).add($1); }
	;

args
	:	/* empty */				{ $$=new Vector<Object>(); }
	|	arglist						
	;

arglist
	:	arglist ',' expr	{ ((Vector<Object>)($1)).add($3); $$=$1; }
	|	expr							{ $$=new Vector<Object>(); ((Vector<Object>)($$)).add($1); }
	;

body
	: '{' bodyexpr '}'	{ $$=((Vector<Object>)($2)).toArray(); }
	;

bodyexpr
	:	bodyexpr expr	';'		{ ((Vector<Object>)($1)).add($2); $$=$1; }
	| expr	';'						{ $$=new Vector<Object>(); ((Vector<Object>)($$)).add($1); }
	;

ifrest
	:	ELSE body														{ $$ = new Object[]{"IF3",$2}; }
	| ELSIF '(' expr ')' body							{ $$ = new Object[]{"IF1",$3,$5}; }
	|	ELSIF '(' expr ')' body ifrest			{ $$ = new Object[]{"IF2",$3,$5,$6}; }
	;

op:	OP1 | OP2 | OP3 | OP4 | OP5 ;

expr
	: RETURN expr
		{ $$ = new Object[]{"RETURN",$2}; }
	| NAME '=' expr
		{ $$ = new Object[]{"STORE",varPos($1),$3}; }
	|	NOT expr
			{ $$ = new Object[]{"NOT",$2}; }
	|	expr AND expr
			{ $$ = new Object[]{"CALL",$1,$3}; }
	|	expr OR expr
			{ $$ = new Object[]{"CALL",$1,$3}; }
	| PRINTLN '(' expr ')'
		{ $$ = new Object[]{"PRINT", $3}; }
	| expr OP1 expr
		{ $$ = new Object[]{"CALL",$2,new Object[]{$1,$3}}; }
	| expr OP2 expr
		{ $$ = new Object[]{"CALL",$2,new Object[]{$1,$3}}; }
	| expr OP3 expr
		{ $$ = new Object[]{"CALL",$2,new Object[]{$1,$3}}; }
	| expr OP4 expr
		{ $$ = new Object[]{"CALL",$2,new Object[]{$1,$3}}; }
	| expr OP5 expr
		{ $$ = new Object[]{"CALL",$2,new Object[]{$1,$3}}; }
	|	'(' expr ')'
		{ $$ = $2; }
	| NAME
		{ $$ = new Object[]{"FETCH",varPos($1)}; }
	| NAME '(' args ')'
		{ $$ = new Object[]{"CALL",$1, ((Vector<Object>)($3)).toArray() }; }
	| WHILE '(' expr ')' body
		{ $$=new Object[]{"WHILE",$3,$5}; }
	| IF '(' expr ')' body
		{ $$ = new Object[]{"IF1",$3,$5}; }
	| IF '(' expr ')' body ifrest
		{ $$ = new Object[]{"IF2",$3,$5,$6}; }
	| LITERAL
		{ $$ = new Object[]{"LITERAL",$1}; }
	|	op expr %prec UNOP
			{ $$ = new Object[]{"CALL",$1,new Object[]{$2}}; }
	;

%%

static private String name;
private NanoMorphoLexer lexer;
private int varCount;
private HashMap<String,Integer> varTable;

private void addVar( String name )
{
  if( varTable.get(name) != null )
  yyerror("Variable "+name+" already exists");
  varTable.put(name,varCount++);
}

private int varPos( String name )
{
	Integer res = varTable.get(name);
	if( res == null )
		yyerror("Variable "+name+" does not exist");
	return res;
}

int last_token_read;

private int yylex()
{
	int yyl_return = -1;
	try
	{
		yylval = null;
		last_token_read = yyl_return = lexer.yylex();
		if( yylval==null )
			yylval = new NanoMorphoParserVal(NanoMorphoParser.yyname[yyl_return]);
	}
	catch (IOException e)
	{
		emit("IO error: "+e);
	}
	return yyl_return;
}

public void yyerror( String error )
{
	emit("Error:  "+error);
	emit("Token:  "+NanoMorphoParser.yyname[last_token_read]);
	System.exit(1);
}

public NanoMorphoParser( Reader r )
{
	lexer = new NanoMorphoLexer(r,this);
}

public static void main( String args[] )
throws IOException
{
  NanoMorphoParser yyparser = new NanoMorphoParser(new FileReader(args[0]));
  name = args[0].substring(0,args[0].lastIndexOf('.'));
  yyparser.yyparse();
}

public static void emit( String s )		/*@ \label{byaccgeneratorstart} @*/
{
  System.out.println(s);
}

static void generateProgram( String name, Object[] p )
{
  emit("\""+name+".mexe\" = main in");
  emit("!{{");
  for( int i=0 ; i!=p.length ; i++ ) generateFunction((Object[])p[i]);
  emit("}}*BASIS;");
}

static void generateFunction( Object[] f )
	{
		String fname = (String)f[0];
		int count = (Integer)f[1];
    int varcount = (Integer)f[2];
		emit("#\""+fname+"[f"+count+"]\" =");
		emit("[");
    if( varcount!=0 ) emit("(MakeVal null)");
		for( int i=0 ; i!=varcount ; i++ ) System.out.println("(Push)");    
		Object[] exprs = (Object[])f[3];
		for( Object e: exprs ) generateExpr((Object[])e);
		emit("];");
	}

static int nextLab = 0;

static void generateExpr( Object[] e )
{
	switch( (String)e[0] )
	{
	case "FETCH":
			emit("(Fetch "+e[1]+")");
			return;
	case "STORE":
			generateExpr((Object[])e[2]); emit("(Store "+e[1]+")");
			return;
	case "IF1":
			{
					// ["IF1",cond,thenpart]
					int endlab = nextLab++;
					generateExpr((Object[])e[1]);
					emit("(GoFalse _"+endlab+")");
					generateBody((Object[])e[2]);
					emit("_"+endlab+":");
					return;
			}
	case "IF2":
			{
					// ["IF2",cond,thenpart,elsepart]
					int elslab = nextLab++;
					int endlab = nextLab++;
					generateExpr((Object[])e[1]);
					emit("(GoFalse _"+elslab+")");
					generateBody((Object[])e[2]);
					emit("(Go _"+endlab+")");
					emit("_"+elslab+":");
					generateExpr((Object[])e[3]);
					emit("_"+endlab+":");
					return;
			}
		case "IF3":
			{
					// ["IF3",elsepart]
					generateBody((Object[])e[1]);
					return;
			}
	case "WHILE":
			{
					int startlab = nextLab++;
					int endlab = nextLab++;
					emit("_"+startlab+":");
					generateExpr((Object[])e[1]);
					emit("(GoFalse _"+endlab+")");
					generateBody((Object[])e[2]);
					emit("(Go _"+startlab+")");
					emit("_"+endlab+":");
					return;
			}
	case "CALL":
			{
					Object[] args = (Object[])e[2];
					if( args.length!=0 ) generateExpr((Object[])args[0]);
					for( int i=1 ; i<args.length ; i++ )
					{
							emit("(Push)");
							generateExpr((Object[])args[i]);
					}
					emit("(Call #\""+e[1]+"[f"+args.length+"]\" "+args.length+")");
					return;
			}
	case "RETURN":
			generateExpr((Object[])e[1]);
			emit("(Return)");
			return;
	case "LITERAL":
			emit("(MakeVal "+e[1]+")");
			return;
	case "NOT":
			// ["NOT",expr]
			generateExpr((Object[])e[1]); emit("(Not)");
			return;
	case "PRINT":
			generateExpr((Object[])e[1]);
			emit("(Call #\""+"writeln"+"[f1]\" 1)");
			return;
	default:
			throw new Error("Invalid expression type: "+e[0]);
	}
}

static void generateBody( Object[] bod )
{
		for( Object e: bod )
		{
				generateExpr((Object[])e);
		}
}

\end{lstlisting}

\section{Jflex skrá}

\begin{lstlisting}
import java.io.*;

%%

%public
%class NanoMorphoLexer
%unicode
%byaccj
%line
%column

%{


public static String lexeme;

public NanoMorphoParser yyparser;

public NanoMorphoLexer( java.io.Reader r, NanoMorphoParser yyparser )
{
	this(r);
	this.yyparser = yyparser;
}

static int priority( String opname )
{
	switch( opname.charAt(0) )
	{
	case '|':
		return 1;
	case '&':
		return 2;
	case '!':
	case '=':
	case '<':
	case '>':
		return 3;
	case '+':
	case '-':
		return 4;
	case '*':
	case '/':
	case '%':
		return 5;
	default:
		throw new Error("Invalid opname");
	}
}

%}

/* Reglulegar skilgreiningar */

/* Regular definitions */

_DIGIT=[0-9]
_FLOAT={_DIGIT}+\.{_DIGIT}+([eE][+-]?{_DIGIT}+)?
_INT={_DIGIT}+
_STRING=\"([^\"\\]|\\b|\\t|\\n|\\f|\\r|\\\"|\\\'|\\\\|(\\[0-3][0-7][0-7])|\\[0-7][0-7]|\\[0-7])*\"
_CHAR=\'([^\'\\]|\\b|\\t|\\n|\\f|\\r|\\\"|\\\'|\\\\|(\\[0-3][0-7][0-7])|(\\[0-7][0-7])|(\\[0-7]))\'
_DELIM=[={},()\[\];]
_NAME=([:letter:]|{_DIGIT})+
_OPNAME=[\+\-*/!%&=><&|]+

%%

/* Lesgreiningarreglur */

{_DELIM} {
yyparser.yylval = new NanoMorphoParserVal(yytext());
return yycharat(0);
}


{_STRING} | {_FLOAT} | {_CHAR} | {_INT} | null | true | false {
yyparser.yylval = new NanoMorphoParserVal(yytext());
return NanoMorphoParser.LITERAL;
}

"println" {
yyparser.yylval = new NanoMorphoParserVal(yytext());
return NanoMorphoParser.PRINTLN;	
}

"return" {
yyparser.yylval = new NanoMorphoParserVal(yytext());
return NanoMorphoParser.RETURN;
}

"else" {
yyparser.yylval = new NanoMorphoParserVal(yytext());
return NanoMorphoParser.ELSE;
}

"elsif" {
yyparser.yylval = new NanoMorphoParserVal(yytext());
return NanoMorphoParser.ELSIF;
}

"while" {
yyparser.yylval = new NanoMorphoParserVal(yytext());
return NanoMorphoParser.WHILE;
}

"if" {
yyparser.yylval = new NanoMorphoParserVal(yytext());
return NanoMorphoParser.IF;
}

"var" {
yyparser.yylval = new NanoMorphoParserVal(yytext());
return NanoMorphoParser.VAR;
}

{_NAME} {
yyparser.yylval = new NanoMorphoParserVal(yytext());
return NanoMorphoParser.NAME;
}

"&&" {
	return NanoMorphoParser.AND;
}

"||" {
	return NanoMorphoParser.OR;
}

"!" {
	return NanoMorphoParser.NOT;
}

{_OPNAME} {
	yyparser.yylval = new NanoMorphoParserVal(yytext());
	switch( yytext().charAt(0) )
	{
	case '|':
		return NanoMorphoParser.OP1;
	case '&':
		return NanoMorphoParser.OP2;
	case '!':
	case '=':
	case '<':
	case '>':
		return NanoMorphoParser.OP3;
	case '+':
	case '-':
		return NanoMorphoParser.OP4;
	case '*':
	case '/':
	case '%':
		return NanoMorphoParser.OP5;
	default:
		throw new Error("Invalid operation name");
	}
}


";;;".*$ {
}

[ \t\r\n\f] {
}

. {
yyparser.yylval = new NanoMorphoParserVal(yytext());
return NanoMorphoParser.ERROR;
}
\end{lstlisting}

\section{Prófun}
Hér er forritið sem prófað var:
\begin{lstlisting}
;;; Fibonacci
fibo(n){
  var ;
  if(n < 0) {
    return n * -1; 
  } elsif( n == 0) { 
    return n * ( 1 - 2);
  } else {
    return fibo(n-1) + fibo(n-2);
  };
}

main(){
  var n;
  n = 0;
  while(n < 12){
    n = n+1;
    println(fibo(n));
  };

  while(n != 0) {
    n = n - 1;
  }

  println(n + 2 * -1 / -2);
  println( true || false && false);

}
\end{lstlisting}

\pagebreak
\textbf{Niðurstaðan úr prófun}

\includegraphics[scale=0.7]{mynd}
\end{document}
